# HyperLogLog (HLL): оценка числа уникальных элементов в потоке

Реализован вероятностный алгоритм **HyperLogLog** для приближённой оценки числа различных (уникальных) строк в потоковых данных.  
Алгоритм сравнивается с точным значением F₀ᵗ (число уникальных элементов на префиксе потока), строятся графики и оценивается точность по теоретическим оценкам.

Дополнительно реализована улучшенная версия (**усреднённый HLL**), которая снижает дисперсию оценки за счёт усреднения нескольких независимых HLL с разными `seed` хеш-функции.

---

## Что делает

1. Генерирует поток случайных строк (длина до 30, алфавит `A-Z a-z 0-9 -`).
2. Считает:
   - **точное** число уникальных элементов F₀ᵗ на префиксе потока;
   - **оценку** Nₜ с помощью базового HyperLogLog;
   - **улучшенную оценку** Nₜ (усреднённый HLL) как среднее по `k` независимым HLL.
3. Проводит эксперименты:
   - один поток (для наглядного сравнения F₀ᵗ, Nₜ базового HLL и Nₜ усреднённого HLL);
   - много потоков (по умолчанию 100) для статистики: среднее и стандартное отклонение оценки.
4. Экспортирует результаты в CSV и строит два графика.

---

## Обозначения

- F₀ᵗ — точное число уникальных строк среди первых t% элементов потока.
- Nₜ — оценка числа уникальных, выдаваемая **базовым** HyperLogLog.
- Nₜᵃᵛᵍ — оценка числа уникальных, выдаваемая **усреднённым** HLL.
- m = 2^B — число регистров HyperLogLog, где `B` — число битов, используемых для выбора регистра.

---

## Параметры эксперимента (по умолчанию)

В `main.cpp`:
- `B = 12`, значит `m = 4096`
- `K = 7` — число независимых скетчей в усреднённой версии
- `STREAM_SIZE = 10000` элементов в потоке
- `NUM_STREAMS = 100` потоков для статистики
- префиксы: `5%, 10%, ..., 100%`

### Почему выбрано `B = 12`
Компромисс между памятью и точностью:
- ожидаемая относительная ошибка (RSE) порядка:

  RSE ≈ 1.04 / √m = 1.04 / √(2¹²) ≈ 1.62%

- память базового HLL: `4096` регистров по 1 байту ≈ **4 КБ**

---

## Улучшенная версия (усреднённый HLL)

### Идея
Запускаем `K` независимых HyperLogLog-скетчей с одинаковым `B`, но **разными `seed`** хеш-функции (Murmur3).  
Для каждого префикса берём среднее по оценкам:

Nᵃᵛᵍₜ = (1 / K) * Σᵢ Nₜ,ᵢ

### Что даёт
- **Снижение дисперсии**: при слабой корреляции оценок дисперсия среднего падает примерно в `K` раз, а стандартное отклонение — примерно в `√K` раз.
- **Цена**: память под регистры растёт примерно в `K` раз (в этой работе используется 1 байт на регистр).

---

## Теоретическая точность

Для HyperLogLog приводим оценку относительной ошибки:

RSE ≈ 1.04 / √(2^B)

Используем более грубую верхнюю границу:

1.3 / √(2^B)

В программе дополнительно выводится (на 100% префиксе):
- **RSE**:

  RSE = σ(N) / E(F₀)

- **Bias** (смещение среднего):

  |E(N) − E(F₀)| / E(F₀)

То же самое печатается отдельно и для усреднённого HLL.

---

## Сборка и запуск

Скомпилировать:

```bash
g++ -O2 -std=c++17 -o hyperloglog   main.cpp HyperLogLog.cpp HyperLogLogAvg.cpp RandomStreamGen.cpp HashFuncGen.cpp
```

Запуск:

```bash
./hyperloglog
```

После запуска появятся файлы:
- `single_stream.csv`
- `stats.csv`

---

## Построение графиков

Нужен Python 3 и библиотеки `pandas`, `matplotlib`.

Установка:

```bash
pip install pandas matplotlib
```

Построение графиков:

```bash
python plot.py
```

Скрипт сохранит:
- `plot1.png` — один поток: F₀ᵗ, N_base и N_avg
- `plot2.png` — 100 потоков: среднее и полоса ±1σ для базового и усреднённого вариантов

---

## Формат выходных данных

### `single_stream.csv`
Колонки:
- `prefix_percent` — размер префикса в процентах
- `F0` — точное число уникальных
- `N_base` — оценка базового HyperLogLog
- `N_avg` — оценка усреднённого HLL (среднее по `K` скетчам)

### `stats.csv`
Колонки:
- `prefix_percent` — размер префикса в процентах
- `F0_mean` — среднее точное число уникальных по потокам
- `N_mean_base` — средняя оценка базового HyperLogLog
- `N_std_base` — стандартное отклонение оценки базового HyperLogLog
- `N_mean_avg` — средняя оценка усреднённого HLL
- `N_std_avg` — стандартное отклонение оценки усреднённого HLL

---

## Пример вывода

```bash
Running experiments: B=12, k=7, streams=100, stream_size=10000
  Processed 10 / 100 streams
  Processed 20 / 100 streams
  Processed 30 / 100 streams
  Processed 40 / 100 streams
  Processed 50 / 100 streams
  Processed 60 / 100 streams
  Processed 70 / 100 streams
  Processed 80 / 100 streams
  Processed 90 / 100 streams
  Processed 100 / 100 streams
Exported: single_stream.csv
Exported: stats.csv

Summary (at 100% prefix)
Theoretical HLL RSE: 1.62%
Theoretical bound: 2.03%
RSE (base HLL): 1.78%
RSE (averaged HLL): 0.87%
Bias (base HLL): 0.003554%
Bias (averaged HLL): 0.189785%

To generate plots: python plot.py
```

---

## Выводы по экспериментам

По результатам запусков (B = 12, m = 4096, K = 7, 100 потоков по 10 000 элементов):

- **Оценка HyperLogLog близка к точному значению**: на графиках линия оценки идёт рядом с точным F₀ᵗ, а средние `N_mean_base` и `F0_mean` близки.
- **Смещение (bias) мало**: величина |E(N) − E(F₀)| / E(F₀) на 100% префиксе мала.
- **Относительная ошибка порядка 1–2%** соответствует теории для выбранного `B`.
- **Усреднённый HLL уменьшает разброс**: `N_std_avg` заметно меньше `N_std_base`, что видно по более узкой полосе ±1σ на втором графике. Это соответствует ожидаемому эффекту уменьшения стандартного отклонения примерно в `√K` раз.
