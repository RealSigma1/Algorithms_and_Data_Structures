# HyperLogLog (HLL): оценка числа уникальных элементов в потоке

Реализован вероятностный алгоритм **HyperLogLog** для приближённой оценки числа различных (уникальных) строк в потоковых данных.  
Алгоритм сравнивается с точным значением F₀ᵗ (число уникальных элементов на префиксе потока), строятся графики и оценивается точность по теоретическим оценкам.

---

## Что делает

1. Генерирует поток случайных строк (длина до 30, алфавит `A-Z a-z 0-9 -`).
2. Считает:
   - **точное** число уникальных элементов F₀ᵗ на префиксе потока;
   - **оценку** Nₜ с помощью HyperLogLog.
3. Проводит эксперименты:
   - один поток (для наглядного сравнения F₀ᵗ и Nₜ);
   - много потоков (по умолчанию 100) для статистики: среднее и стандартное отклонение оценки.
4. Экспортирует результаты в CSV и строит два графика.

---

## Обозначения

- F₀ᵗ — точное число уникальных строк среди первых t% элементов потока.
- Nₜ — оценка числа уникальных, выдаваемая HyperLogLog.
- m = 2^B — число регистров HyperLogLog, где `B` — число битов, используемых для выбора регистра.

---

## Параметры эксперимента (по умолчанию)

В `main.cpp`:
- `B = 12`, значит `m = 4096`
- `STREAM_SIZE = 10000` элементов в потоке
- `NUM_STREAMS = 100` потоков для статистики
- префиксы: `5%, 10%, ..., 100%`

### Почему выбрано `B = 12`
Компромисс между памятью и точностью:
- ожидаемая относительная ошибка (RSE) порядка:

  RSE ≈ 1.04 / √m = 1.04 / √(2¹²) ≈ 1.62%

- память: `4096` регистров по 1 байту ≈ **4 КБ** (очень мало)

---

## Теоретическая точность

Для HyperLogLog  приводим оценку относительной ошибки:

RSE ≈ 1.04 / √(2^B)

Используем более грубую верхнюю границу:

1.3 / √(2^B)

В программе дополнительно выводится:
- **Observed RSE** на 100% префиксе:

  RSE = σ(N) / E(F₀)

- **Bias** (смещение среднего):

  |E(N) − E(F₀)| / E(F₀)

---

## Сборка и запуск


Скомпилировать:

```bash
g++ -O2 -std=c++17 -o hyperloglog main.cpp HyperLogLog.cpp RandomStreamGen.cpp HashFuncGen.cpp
```

Запуск:

```bash
./hyperloglog
```

После запуска появятся файлы:
- `single_stream.csv`
- `stats.csv`

---

## Построение графиков

Нужен Python 3 и библиотеки `pandas`, `matplotlib`.

Установка:

```bash
pip install pandas matplotlib
```

Построение графиков:

```bash
python plot.py
```

Скрипт сохранит:
- `plot1.png` — один поток: F₀ᵗ и оценка HLL
- `plot2.png` — 100 потоков: среднее и полоса ±1σ

---

## Формат выходных данных

### `single_stream.csv`
Колонки:
- `prefix_percent` — размер префикса в процентах
- `F0` — точное число уникальных
- `N` — оценка HyperLogLog

### `stats.csv`
Колонки:
- `prefix_percent` — размер префикса в процентах
- `F0_mean` — среднее точное число уникальных по потокам
- `N_mean` — средняя оценка HyperLogLog
- `N_std` — стандартное отклонение оценки HyperLogLog

---

## Результат

```bash
Running experiments (b=12, streams=100)...
  Processed 10 streams
  Processed 20 streams
  Processed 30 streams
  Processed 40 streams
  Processed 50 streams
  Processed 60 streams
  Processed 70 streams
  Processed 80 streams
  Processed 90 streams
  Processed 100 streams
Exported: single_stream.csv
Exported: stats.csv

=== Results ===
Theoretical RSE: 1.62%
Theoretical bound: 2.03%
Observed RSE: 1.78%
Bias: 0.003554%

To generate plots:
  python plot.py
```
---

## Выводы по экспериментам

По результатам запусков (B = 12, m = 4096, 100 потоков по 10 000 элементов):

- **Оценка HyperLogLog близка к точному значению**: на графиках линия оценки Nₜ идёт практически вместе с точным F₀ᵗ, а средние значения N_mean и F0_mean практически совпадают.
- **Смещение (bias) почти отсутствует**: величина |E(N) − E(F₀)| / E(F₀) на 100% префиксе очень мала.
- **Относительная ошибка остаётся порядка 1–2%** при росте размера префикса: абсолютный разброс растёт вместе с числом уникальных, но относительный (RSE) определяется главным образом числом регистров m = 2^B.

